let Joi,User,CustomErrorHandler,bcrypt,JwtService;_714‍.x([["default",()=>_714‍.o]]);_714‍.w("joi",[["default",["Joi"],function(v){Joi=v}]]);_714‍.w("../../models",[["User",["User"],function(v){User=v}]]);_714‍.w("../../services/CustomErrorHandler",[["default",["CustomErrorHandler"],function(v){CustomErrorHandler=v}]]);_714‍.w("bcrypt",[["default",["bcrypt"],function(v){bcrypt=v}]]);_714‍.w("../../services/JwtService",[["default",["JwtService"],function(v){JwtService=v}]]);





const loginController = {
  async login(req,res,next){
    //validation
    const loginSchema = Joi.object({
      email:Joi.string().email().required(),
      password:Joi.string().pattern(new RegExp('^[a-zA-Z0-9]{3,30}$')).required()
    });

    const {error} = loginSchema.validate(req.body);

    if(error){
      return next(error);
    }

    try{
      const user = await User.findOne({email:req.body.email });
      if(!user){
        return next(CustomErrorHandler.wrongCredentials());
      }

      //compare the password
      const match = await bcrypt.compare(req.body.password,user.password);
      if(!match){
        return next(CustomErrorHandler.wrongCredentials());
      }

      const access_token = JwtService.sign({_id:user._id,role:user.role});
      res.json({access_token:access_token});
    }catch(err){
      return next(err);
    }
  }
}

_714‍.d(loginController);