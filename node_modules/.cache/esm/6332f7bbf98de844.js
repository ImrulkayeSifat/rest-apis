let Joi,CustomErrorHandler,User,RefreshToken,bcrypt,JwtService,REFRESH_SECRET;_f98‍.x([["default",()=>_f98‍.o]]);_f98‍.w("joi",[["default",["Joi"],function(v){Joi=v}]]);_f98‍.w("../../services/CustomErrorHandler",[["default",["CustomErrorHandler"],function(v){CustomErrorHandler=v}]]);_f98‍.w("../../models",[["User",["User"],function(v){User=v}],["RefreshToken",["RefreshToken"],function(v){RefreshToken=v}]]);_f98‍.w("bcrypt",[["default",["bcrypt"],function(v){bcrypt=v}]]);_f98‍.w("../../services/JwtService",[["default",["JwtService"],function(v){JwtService=v}]]);_f98‍.w("../../config",[["REFRESH_SECRET",["REFRESH_SECRET"],function(v){REFRESH_SECRET=v}]]);






const registerController = {
  async register(req,res,next){
    //validate the request
    const registerSchema = Joi.object({
      name:Joi.string().min(3).max(30).required,
      email:Joi.string().email().required(),
      password:Joi.string().pattern(new RegExp('^[a-zA-Z0-9]{3,30}$')).required(),
      repeat_password:Joi.ref('password')
    })

    const [error] = registerSchema.validate(req.body);

    if(error){
      return next(error);
    }
    
    //authorise the request
    //check if user is in the database already

    try{
      const exist = await User.exits({email:req.body.email});
      if(exist){
        return next(CustomErrorHandler.alreadyExist('this email is already taken!'))
      }
    }catch(err){
      return next(err);
    }

    //Hash password
    const {name,email,password} = req.body;
    const hashedPassword = await bcrypt.hash(password,10);

    //prepare model
    
    const user = new User({
      name,
      email,
      password:hashedPassword
    });

    //store in database
    let access_token;
    let refresh_token;
    try{
      const result = await user.save();

      //generate jwt token
      access_token = JwtService.sign({_id:result._id,role:result.role});
      refresh_token = JwtService.sign({_id:result._id,role:result.role},'1y',REFRESH_SECRET);

      //database whitelist

      await RefreshToken.create({token:refresh_token});
    }catch(err){
      return next(err);
    }
    
    //send response
    res.json({access_token,refresh_token});
  }
}

_f98‍.d(registerController);